<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulpes: vulpes::datastructure::KDTree&lt; Dim &gt; Class Template Reference</title>
<link rel="icon" href="vulpes_logo_notext_32.png" type="image/png" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-vulpes.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-vulpes.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vulpes
   &#160;<span id="projectnumber">0.0.2-alpha</span>
   </div>
   <div id="projectbrief">Virtual and Discontinuous Polytopal Elements Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvulpes_1_1datastructure_1_1KDTree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvulpes_1_1datastructure_1_1KDTree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vulpes::datastructure::KDTree&lt; Dim &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> is a data structure for efficiently querying nearest neighbors and performing spatial searches in a k-dimensional space.  
 <a href="classvulpes_1_1datastructure_1_1KDTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="kdtree_8hpp_source.html">kdtree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48cd00d6df1c85711fd51c2f60676a0e" id="r_a48cd00d6df1c85711fd51c2f60676a0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a48cd00d6df1c85711fd51c2f60676a0e">KDTree</a> (const std::vector&lt; std::array&lt; double, Dim &gt; &gt; &amp;data)</td></tr>
<tr class="memdesc:a48cd00d6df1c85711fd51c2f60676a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> from a vector of data points.  <br /></td></tr>
<tr class="separator:a48cd00d6df1c85711fd51c2f60676a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67231f00b50fbd3486c54773a571dfa4" id="r_a67231f00b50fbd3486c54773a571dfa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a67231f00b50fbd3486c54773a571dfa4">KDTree</a> (const double *data, int64_t size)</td></tr>
<tr class="memdesc:a67231f00b50fbd3486c54773a571dfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> using a raw pointer to the data.  <br /></td></tr>
<tr class="separator:a67231f00b50fbd3486c54773a571dfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77b0d727edefce0d37e88fbab7ec1d4" id="r_aa77b0d727edefce0d37e88fbab7ec1d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#aa77b0d727edefce0d37e88fbab7ec1d4">KDTree</a> (const double *data, const std::vector&lt; int64_t &gt; &amp;indices)</td></tr>
<tr class="memdesc:aa77b0d727edefce0d37e88fbab7ec1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> using a raw pointer to the data.  <br /></td></tr>
<tr class="separator:aa77b0d727edefce0d37e88fbab7ec1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a9ca8f107e9dd3c7382d7bbad20ed" id="r_a285a9ca8f107e9dd3c7382d7bbad20ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a285a9ca8f107e9dd3c7382d7bbad20ed">build</a> (int64_t leafsize, bool median, bool compact)</td></tr>
<tr class="memdesc:a285a9ca8f107e9dd3c7382d7bbad20ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>.  <br /></td></tr>
<tr class="separator:a285a9ca8f107e9dd3c7382d7bbad20ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45f417b201340aefc744287a6037f6" id="r_a8e45f417b201340aefc744287a6037f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a8e45f417b201340aefc744287a6037f6">build</a> (const std::array&lt; double, 2 *Dim &gt; &amp;boxsize, int64_t leafsize, bool median, bool compact)</td></tr>
<tr class="memdesc:a8e45f417b201340aefc744287a6037f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> with specified bounding box sizes.  <br /></td></tr>
<tr class="separator:a8e45f417b201340aefc744287a6037f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964a2ea0b007ddf2498d264992945c24" id="r_a964a2ea0b007ddf2498d264992945c24"><td class="memTemplParams" colspan="2">template&lt;double PNorm, bool Periodic = false&gt; </td></tr>
<tr class="memitem:a964a2ea0b007ddf2498d264992945c24"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::Matrix&lt; int64_t, -1, -1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a964a2ea0b007ddf2498d264992945c24">queryKnn</a> (const double *points, int64_t n_points, int64_t k, double eps=0, double distance_upper_bound=std::numeric_limits&lt; double &gt;::max()) const</td></tr>
<tr class="memdesc:a964a2ea0b007ddf2498d264992945c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for k-nearest neighbors (KNN) of a set of points.  <br /></td></tr>
<tr class="separator:a964a2ea0b007ddf2498d264992945c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dbc52612fb1454490de3df0640cc5c" id="r_a08dbc52612fb1454490de3df0640cc5c"><td class="memTemplParams" colspan="2">template&lt;double PNorm, bool Periodic = false&gt; </td></tr>
<tr class="memitem:a08dbc52612fb1454490de3df0640cc5c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::Matrix&lt; int64_t, -1, -1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a08dbc52612fb1454490de3df0640cc5c">queryKnn</a> (const std::vector&lt; std::array&lt; double, Dim &gt; &gt; &amp;points, int64_t k, double eps=0, double distance_upper_bound=std::numeric_limits&lt; double &gt;::max()) const</td></tr>
<tr class="memdesc:a08dbc52612fb1454490de3df0640cc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for k-nearest neighbors (KNN) of a set of points.  <br /></td></tr>
<tr class="separator:a08dbc52612fb1454490de3df0640cc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac00f2aba764bc7bbf8af7bc4ea4cc0" id="r_aaac00f2aba764bc7bbf8af7bc4ea4cc0"><td class="memTemplParams" colspan="2">template&lt;double PNorm, bool Periodic = false&gt; </td></tr>
<tr class="memitem:aaac00f2aba764bc7bbf8af7bc4ea4cc0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacevulpes_1_1scipy.html#ad4a6f40daf2691d41a89ea6f16656768">scipy::ckdtree_intp_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#aaac00f2aba764bc7bbf8af7bc4ea4cc0">queryBall</a> (const double *points, const double *radiuses, int64_t n_queries, double eps=0.0, bool return_length=false, bool sort_output=true) const</td></tr>
<tr class="memdesc:aaac00f2aba764bc7bbf8af7bc4ea4cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for all points within a given radius of a set of input points.  <br /></td></tr>
<tr class="separator:aaac00f2aba764bc7bbf8af7bc4ea4cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599ba87f2e31e6d0b061ae14d1e5e4b4" id="r_a599ba87f2e31e6d0b061ae14d1e5e4b4"><td class="memTemplParams" colspan="2">template&lt;double PNorm, bool Periodic = false&gt; </td></tr>
<tr class="memitem:a599ba87f2e31e6d0b061ae14d1e5e4b4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacevulpes_1_1scipy.html#ad4a6f40daf2691d41a89ea6f16656768">scipy::ckdtree_intp_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a599ba87f2e31e6d0b061ae14d1e5e4b4">queryBall</a> (const std::vector&lt; std::array&lt; double, Dim &gt; &gt; &amp;points, const std::vector&lt; double &gt; &amp;radiuses, double eps=0.0, bool return_length=false, bool sort_output=true) const</td></tr>
<tr class="memdesc:a599ba87f2e31e6d0b061ae14d1e5e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for all points within a given radius of a set of input points.  <br /></td></tr>
<tr class="separator:a599ba87f2e31e6d0b061ae14d1e5e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11277918cd88497194211fffcfdebb85" id="r_a11277918cd88497194211fffcfdebb85"><td class="memTemplParams" colspan="2">template&lt;double PNorm, bool Periodic = false&gt; </td></tr>
<tr class="memitem:a11277918cd88497194211fffcfdebb85"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structvulpes_1_1scipy_1_1ordered__pair.html">scipy::ordered_pair</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a11277918cd88497194211fffcfdebb85">queryPairs</a> (double r, double eps=0.0) const</td></tr>
<tr class="memdesc:a11277918cd88497194211fffcfdebb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all pairs of points whose distance is within a given radius.  <br /></td></tr>
<tr class="separator:a11277918cd88497194211fffcfdebb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac276a48e175c68b5ae58bd542ef7f6d2" id="r_ac276a48e175c68b5ae58bd542ef7f6d2"><td class="memTemplParams" colspan="2">template&lt;double PNorm, bool Periodic = false&gt; </td></tr>
<tr class="memitem:ac276a48e175c68b5ae58bd542ef7f6d2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacevulpes_1_1scipy.html#ad4a6f40daf2691d41a89ea6f16656768">scipy::ckdtree_intp_t</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#ac276a48e175c68b5ae58bd542ef7f6d2">queryBallTree</a> (const <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">KDTree</a>&lt; Dim &gt; &amp;other, double r, double eps=0.0) const</td></tr>
<tr class="memdesc:ac276a48e175c68b5ae58bd542ef7f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all points within a given radius from another <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>.  <br /></td></tr>
<tr class="separator:ac276a48e175c68b5ae58bd542ef7f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a45329daf3c2eb341f123cbdf000e80ce" id="r_a45329daf3c2eb341f123cbdf000e80ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a45329daf3c2eb341f123cbdf000e80ce">buildRun</a> (bool median, bool compact)</td></tr>
<tr class="memdesc:a45329daf3c2eb341f123cbdf000e80ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to build the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>.  <br /></td></tr>
<tr class="separator:a45329daf3c2eb341f123cbdf000e80ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade39e9120455bfc4b4a77688c5f5c56e" id="r_ade39e9120455bfc4b4a77688c5f5c56e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#ade39e9120455bfc4b4a77688c5f5c56e">postInitTraverse</a> (<a class="el" href="structvulpes_1_1scipy_1_1ckdtreenode.html">scipy::ckdtreenode</a> *root, <a class="el" href="structvulpes_1_1scipy_1_1ckdtreenode.html">scipy::ckdtreenode</a> *node)</td></tr>
<tr class="memdesc:ade39e9120455bfc4b4a77688c5f5c56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs post-initialization traversal of the tree to adjust node pointers.  <br /></td></tr>
<tr class="separator:ade39e9120455bfc4b4a77688c5f5c56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1321de0df8a427fa7049a87e9235fa" id="r_a4b1321de0df8a427fa7049a87e9235fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a4b1321de0df8a427fa7049a87e9235fa">compututeBounds</a> ()</td></tr>
<tr class="memdesc:a4b1321de0df8a427fa7049a87e9235fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bounding box (max and min values) for the data points.  <br /></td></tr>
<tr class="separator:a4b1321de0df8a427fa7049a87e9235fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7ad054d96149c730293d869d45cb3f2e" id="r_a7ad054d96149c730293d869d45cb3f2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a7ad054d96149c730293d869d45cb3f2e">m_is_built</a> = false</td></tr>
<tr class="separator:a7ad054d96149c730293d869d45cb3f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc859ecdc7abfa572d4afd72e7d12751" id="r_acc859ecdc7abfa572d4afd72e7d12751"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#acc859ecdc7abfa572d4afd72e7d12751">m_leafsize</a> = -1</td></tr>
<tr class="separator:acc859ecdc7abfa572d4afd72e7d12751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a51f1e5fa97d0355226c30c177233b" id="r_a56a51f1e5fa97d0355226c30c177233b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structvulpes_1_1scipy_1_1ckdtreenode.html">scipy::ckdtreenode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a56a51f1e5fa97d0355226c30c177233b">m_tree_buffer</a></td></tr>
<tr class="separator:a56a51f1e5fa97d0355226c30c177233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f8d1522b65393856ec6cd02240b46" id="r_a953f8d1522b65393856ec6cd02240b46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a953f8d1522b65393856ec6cd02240b46">m_data</a></td></tr>
<tr class="separator:a953f8d1522b65393856ec6cd02240b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845a3b93a738b7da283e5d889b0fb3a5" id="r_a845a3b93a738b7da283e5d889b0fb3a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a845a3b93a738b7da283e5d889b0fb3a5">m_indices</a></td></tr>
<tr class="separator:a845a3b93a738b7da283e5d889b0fb3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a7e6b534038687fdf5aa8d0aa9e786" id="r_a66a7e6b534038687fdf5aa8d0aa9e786"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a66a7e6b534038687fdf5aa8d0aa9e786">m_raw_data</a> = nullptr</td></tr>
<tr class="separator:a66a7e6b534038687fdf5aa8d0aa9e786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b3e25e8ba44fc47d9d81e2e07670a7" id="r_a05b3e25e8ba44fc47d9d81e2e07670a7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a05b3e25e8ba44fc47d9d81e2e07670a7">m_raw_data_size</a> = 0</td></tr>
<tr class="separator:a05b3e25e8ba44fc47d9d81e2e07670a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40c5ea8b9d050eb31e373956185a2e0" id="r_af40c5ea8b9d050eb31e373956185a2e0"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#af40c5ea8b9d050eb31e373956185a2e0">m_maxs</a> {{-std::numeric_limits&lt;double&gt;::max()}}</td></tr>
<tr class="separator:af40c5ea8b9d050eb31e373956185a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f81e6b81fae94a3a6ff7dfcb84ee4d" id="r_aa4f81e6b81fae94a3a6ff7dfcb84ee4d"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#aa4f81e6b81fae94a3a6ff7dfcb84ee4d">m_mins</a> {{std::numeric_limits&lt;double&gt;::max()}}</td></tr>
<tr class="separator:aa4f81e6b81fae94a3a6ff7dfcb84ee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1970dbefc1813cac737d537c047808" id="r_a9d1970dbefc1813cac737d537c047808"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 2 *Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a9d1970dbefc1813cac737d537c047808">m_boxsize</a> = {0}</td></tr>
<tr class="separator:a9d1970dbefc1813cac737d537c047808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1467c7cb36cab59f7d5b654ad01af010" id="r_a1467c7cb36cab59f7d5b654ad01af010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvulpes_1_1scipy_1_1ckdtree.html">scipy::ckdtree</a>&lt; Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html#a1467c7cb36cab59f7d5b654ad01af010">m_tree</a></td></tr>
<tr class="separator:a1467c7cb36cab59f7d5b654ad01af010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int64_t Dim&gt;<br />
class vulpes::datastructure::KDTree&lt; Dim &gt;</div><p><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> is a data structure for efficiently querying nearest neighbors and performing spatial searches in a k-dimensional space. </p>
<p>This class template provides an interface for constructing a KD-tree from a set of points in k-dimensional space, and supports various spatial queries such as k-nearest neighbor searches and ball queries. The implementation relies on a code inspired by <code>scipy.spatial.cKDTree</code>.</p>
<p>The algorithm used is described in Maneewongvatana and Mount 1999. The general idea is that the kd-tree is a binary tree, each of whose nodes represents an axis-aligned hyperrectangle. Each node specifies an axis and splits the set of points based on whether their coordinate along that axis is greater than or less than a particular value. During construction, the axis and splitting point are chosen by the "sliding midpoint" rule, which ensures that the cells do not all become long and thin. The tree can be queried for the r closest neighbors of any given point (optionally returning only those within some maximum distance of the point). It can also be queried, with a substantial gain in efficiency, for the r approximate closest neighbors. For large dimensions (20 is already large) do not expect this to run significantly faster than brute force. High-dimensional nearest-neighbor queries are a substantial open problem in computer science.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim</td><td>The number of dimensions in the data points (k-dimensions).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm is particularly suited for bulk-loading data. If your task necessitates re-building the tree (e.g. to track particles) better suited datastuctures are the R-tree and quadtree/octree </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a48cd00d6df1c85711fd51c2f60676a0e" name="a48cd00d6df1c85711fd51c2f60676a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cd00d6df1c85711fd51c2f60676a0e">&#9670;&#160;</a></span>KDTree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::KDTree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; double, Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> from a vector of data points. </p>
<p>Each point is represented as a std::array&lt;double, Dim&gt;. The data is copied internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A vector of k-dimensional data points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67231f00b50fbd3486c54773a571dfa4" name="a67231f00b50fbd3486c54773a571dfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67231f00b50fbd3486c54773a571dfa4">&#9670;&#160;</a></span>KDTree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::KDTree </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> using a raw pointer to the data. </p>
<p>This constructor is useful if the data is already available in a contiguous array of doubles. The <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> will use the raw data directly, without copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the raw data array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of doubles in the data array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77b0d727edefce0d37e88fbab7ec1d4" name="aa77b0d727edefce0d37e88fbab7ec1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77b0d727edefce0d37e88fbab7ec1d4">&#9670;&#160;</a></span>KDTree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::KDTree </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> using a raw pointer to the data. </p>
<p>This constructor is useful if the data is already available in a sparse array of doubles. The <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> will use the raw data directly, without copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the raw data array. </td></tr>
    <tr><td class="paramname">indices</td><td>The indices of the points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e45f417b201340aefc744287a6037f6" name="a8e45f417b201340aefc744287a6037f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e45f417b201340aefc744287a6037f6">&#9670;&#160;</a></span>build() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::build </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 2 *Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>leafsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>median</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> with specified bounding box sizes. </p>
<p>This version of the build method allows specifying a bounding box size, which is necessary for periodic boundary conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxsize</td><td>Apply a m-d toroidal topology to the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>. The topology is generated by $x_i + n_i L_i$ where $n_i$ are integers and $L_i$ is the boxsize along i-th dimension. The input data shall be wrapped into $[0, L_i)$. </td></tr>
    <tr><td class="paramname">leafsize</td><td>The maximum number of points in a leaf node. </td></tr>
    <tr><td class="paramname">median</td><td>If true, the tree will use median-based splitting. </td></tr>
    <tr><td class="paramname">compact</td><td>If true, the kd-tree is built to shrink the hyperrectangles to the actual data range. This usually gives a more compact tree that is robust against degenerated input data and gives faster queries at the expense of longer build time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a285a9ca8f107e9dd3c7382d7bbad20ed" name="a285a9ca8f107e9dd3c7382d7bbad20ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285a9ca8f107e9dd3c7382d7bbad20ed">&#9670;&#160;</a></span>build() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::build </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>leafsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>median</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>. </p>
<p>This function constructs the tree structure. The tree can be built using either a median-based or sliding-midpoint strategy for splitting nodes, and the user can choose to compact the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leafsize</td><td>The maximum number of points in a leaf node. </td></tr>
    <tr><td class="paramname">median</td><td>If true, the tree will use median-based splitting. </td></tr>
    <tr><td class="paramname">compact</td><td>If true, the kd-tree is built to shrink the hyperrectangles to the actual data range. This usually gives a more compact tree that is robust against degenerated input data and gives faster queries at the expense of longer build time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45329daf3c2eb341f123cbdf000e80ce" name="a45329daf3c2eb341f123cbdf000e80ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45329daf3c2eb341f123cbdf000e80ce">&#9670;&#160;</a></span>buildRun()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::buildRun </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>median</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to build the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>. </p>
<p>This function is responsible for setting up the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> structure, computing the bounds for the points, and invoking the tree building process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">median</td><td>If true, the tree will use median-based splitting. </td></tr>
    <tr><td class="paramname">compact</td><td>If true, the tree will compact the data to minimize memory usage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1321de0df8a427fa7049a87e9235fa" name="a4b1321de0df8a427fa7049a87e9235fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1321de0df8a427fa7049a87e9235fa">&#9670;&#160;</a></span>compututeBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::compututeBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bounding box (max and min values) for the data points. </p>
<p>This function calculates the minimum and maximum coordinates in each dimension, which are used to bound the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>. </p>

</div>
</div>
<a id="ade39e9120455bfc4b4a77688c5f5c56e" name="ade39e9120455bfc4b4a77688c5f5c56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade39e9120455bfc4b4a77688c5f5c56e">&#9670;&#160;</a></span>postInitTraverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::postInitTraverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvulpes_1_1scipy_1_1ckdtreenode.html">scipy::ckdtreenode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvulpes_1_1scipy_1_1ckdtreenode.html">scipy::ckdtreenode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs post-initialization traversal of the tree to adjust node pointers. </p>
<p>Fixes the pointers within the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> nodes. The pointers are meaningless if the underlying vector reallocates the buffer during the resize. Thus everything must be fixex once the tree stops growing. The same is done in the cython code used in scipy</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>. </td></tr>
    <tr><td class="paramname">node</td><td>Pointer to the current node being processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaac00f2aba764bc7bbf8af7bc4ea4cc0" name="aaac00f2aba764bc7bbf8af7bc4ea4cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac00f2aba764bc7bbf8af7bc4ea4cc0">&#9670;&#160;</a></span>queryBall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<div class="memtemplate">
template&lt;double PNorm, bool Periodic = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacevulpes_1_1scipy.html#ad4a6f40daf2691d41a89ea6f16656768">scipy::ckdtree_intp_t</a> &gt; &gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::queryBall </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>radiuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n_queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_length</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_output</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for all points within a given radius of a set of input points. </p>
<p>This method finds all points within a specified radius around each query point. It uses the specified p-norm for distance calculations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PNorm</td><td>The p-norm to use for distance calculation. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Whether to use periodic boundary conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Pointer to the input vector or points. </td></tr>
    <tr><td class="paramname">radiuses</td><td>Pointer to the array of radius values. </td></tr>
    <tr><td class="paramname">n_queries</td><td>The number of query points. </td></tr>
    <tr><td class="paramname">eps</td><td>Approximation tolerance (default is exact search). </td></tr>
    <tr><td class="paramname">return_length</td><td>Whether to return the length of each result set. </td></tr>
    <tr><td class="paramname">sort_output</td><td>Whether to sort the output by distance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors containing the indices of points found within each radius. </dd></dl>

</div>
</div>
<a id="a599ba87f2e31e6d0b061ae14d1e5e4b4" name="a599ba87f2e31e6d0b061ae14d1e5e4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599ba87f2e31e6d0b061ae14d1e5e4b4">&#9670;&#160;</a></span>queryBall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<div class="memtemplate">
template&lt;double PNorm, bool Periodic = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacevulpes_1_1scipy.html#ad4a6f40daf2691d41a89ea6f16656768">scipy::ckdtree_intp_t</a> &gt; &gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::queryBall </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; double, Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radiuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_length</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_output</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for all points within a given radius of a set of input points. </p>
<p>This overload allows querying with std::vector data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PNorm</td><td>The p-norm to use for distance calculation. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Whether to use periodic boundary conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The input points stored in a std::vector. </td></tr>
    <tr><td class="paramname">radiuses</td><td>A vector containing radius values for each point. </td></tr>
    <tr><td class="paramname">eps</td><td>Approximation tolerance (default is exact search). </td></tr>
    <tr><td class="paramname">return_length</td><td>Whether to return the length of each result set. </td></tr>
    <tr><td class="paramname">sort_output</td><td>Whether to sort the output by distance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors containing the indices of points found within each radius. </dd></dl>

</div>
</div>
<a id="ac276a48e175c68b5ae58bd542ef7f6d2" name="ac276a48e175c68b5ae58bd542ef7f6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac276a48e175c68b5ae58bd542ef7f6d2">&#9670;&#160;</a></span>queryBallTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<div class="memtemplate">
template&lt;double PNorm, bool Periodic = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacevulpes_1_1scipy.html#ad4a6f40daf2691d41a89ea6f16656768">scipy::ckdtree_intp_t</a> &gt; &gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::queryBallTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">KDTree</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all points within a given radius from another <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>. </p>
<p>This method performs a ball query between the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> and another <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a>, finding all points within the given radius <code>r</code> across the two trees.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PNorm</td><td>The p-norm to use for distance calculation. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Whether to use periodic boundary conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> to query against. </td></tr>
    <tr><td class="paramname">r</td><td>The radius within which to search. </td></tr>
    <tr><td class="paramname">eps</td><td>Approximation tolerance (default is exact search). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of indices representing the points found in both trees within the radius. </dd></dl>

</div>
</div>
<a id="a964a2ea0b007ddf2498d264992945c24" name="a964a2ea0b007ddf2498d264992945c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964a2ea0b007ddf2498d264992945c24">&#9670;&#160;</a></span>queryKnn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<div class="memtemplate">
template&lt;double PNorm, bool Periodic = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, Eigen::Matrix&lt; int64_t, -1, -1 &gt; &gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::queryKnn </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>n_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_upper_bound</em> = <code>std::numeric_limits&lt;double&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for k-nearest neighbors (KNN) of a set of points. </p>
<p>Finds the k-nearest neighbors for a set of input points, using a specified distance metric (PNorm). This version allows querying with raw data pointers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PNorm</td><td>The p-norm to use for distance calculation (e.g., 2.0 for Euclidean). </td></tr>
    <tr><td class="paramname">Periodic</td><td>Whether to use periodic boundary conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>Pointer to the input vector of points. </td></tr>
    <tr><td class="paramname">n_points</td><td>The number of input points. </td></tr>
    <tr><td class="paramname">k</td><td>The number of nearest neighbors to find. </td></tr>
    <tr><td class="paramname">eps</td><td>Approximate nearest neighbor search tolerance (default is exact search). </td></tr>
    <tr><td class="paramname">distance_upper_bound</td><td>Upper bound on the search radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of matrices, where the first matrix contains distances and the second matrix contains indices of the nearest neighbors. </dd></dl>

</div>
</div>
<a id="a08dbc52612fb1454490de3df0640cc5c" name="a08dbc52612fb1454490de3df0640cc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dbc52612fb1454490de3df0640cc5c">&#9670;&#160;</a></span>queryKnn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<div class="memtemplate">
template&lt;double PNorm, bool Periodic = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, Eigen::Matrix&lt; int64_t, -1, -1 &gt; &gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::queryKnn </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; double, Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_upper_bound</em> = <code>std::numeric_limits&lt;double&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for k-nearest neighbors (KNN) of a set of points. </p>
<p>This overload allows querying with std::vector data, which is useful when the data is in std::array format.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PNorm</td><td>The p-norm to use for distance calculation. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Whether to use periodic boundary conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The input points stored in a std::vector. </td></tr>
    <tr><td class="paramname">k</td><td>The number of nearest neighbors to find. </td></tr>
    <tr><td class="paramname">eps</td><td>Approximate nearest neighbor search tolerance (default is exact search). </td></tr>
    <tr><td class="paramname">distance_upper_bound</td><td>Upper bound on the search radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of matrices, where the first matrix contains distances and the second matrix contains indices of the nearest neighbors. </dd></dl>

</div>
</div>
<a id="a11277918cd88497194211fffcfdebb85" name="a11277918cd88497194211fffcfdebb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11277918cd88497194211fffcfdebb85">&#9670;&#160;</a></span>queryPairs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<div class="memtemplate">
template&lt;double PNorm, bool Periodic = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structvulpes_1_1scipy_1_1ordered__pair.html">scipy::ordered_pair</a> &gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::queryPairs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all pairs of points whose distance is within a given radius. </p>
<p>This method queries the <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html" title="KDTree is a data structure for efficiently querying nearest neighbors and performing spatial searches...">KDTree</a> for all pairs of points whose distances are within a specified radius <code>r</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PNorm</td><td>The p-norm to use for distance calculation. </td></tr>
    <tr><td class="paramname">Periodic</td><td>Whether to use periodic boundary conditions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The radius within which to search for pairs. </td></tr>
    <tr><td class="paramname">eps</td><td>Approximation tolerance (default is exact search). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs (indices) representing the points within the radius. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9d1970dbefc1813cac737d537c047808" name="a9d1970dbefc1813cac737d537c047808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1970dbefc1813cac737d537c047808">&#9670;&#160;</a></span>m_boxsize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;double, 2 * Dim&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_boxsize = {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a953f8d1522b65393856ec6cd02240b46" name="a953f8d1522b65393856ec6cd02240b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f8d1522b65393856ec6cd02240b46">&#9670;&#160;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a845a3b93a738b7da283e5d889b0fb3a5" name="a845a3b93a738b7da283e5d889b0fb3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845a3b93a738b7da283e5d889b0fb3a5">&#9670;&#160;</a></span>m_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int64_t&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ad054d96149c730293d869d45cb3f2e" name="a7ad054d96149c730293d869d45cb3f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad054d96149c730293d869d45cb3f2e">&#9670;&#160;</a></span>m_is_built</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_is_built = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc859ecdc7abfa572d4afd72e7d12751" name="acc859ecdc7abfa572d4afd72e7d12751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc859ecdc7abfa572d4afd72e7d12751">&#9670;&#160;</a></span>m_leafsize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_leafsize = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af40c5ea8b9d050eb31e373956185a2e0" name="af40c5ea8b9d050eb31e373956185a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40c5ea8b9d050eb31e373956185a2e0">&#9670;&#160;</a></span>m_maxs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;double, Dim&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_maxs {{-std::numeric_limits&lt;double&gt;::max()}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4f81e6b81fae94a3a6ff7dfcb84ee4d" name="aa4f81e6b81fae94a3a6ff7dfcb84ee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f81e6b81fae94a3a6ff7dfcb84ee4d">&#9670;&#160;</a></span>m_mins</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;double, Dim&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_mins {{std::numeric_limits&lt;double&gt;::max()}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a7e6b534038687fdf5aa8d0aa9e786" name="a66a7e6b534038687fdf5aa8d0aa9e786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a7e6b534038687fdf5aa8d0aa9e786">&#9670;&#160;</a></span>m_raw_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double* <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_raw_data = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05b3e25e8ba44fc47d9d81e2e07670a7" name="a05b3e25e8ba44fc47d9d81e2e07670a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b3e25e8ba44fc47d9d81e2e07670a7">&#9670;&#160;</a></span>m_raw_data_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_raw_data_size = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1467c7cb36cab59f7d5b654ad01af010" name="a1467c7cb36cab59f7d5b654ad01af010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1467c7cb36cab59f7d5b654ad01af010">&#9670;&#160;</a></span>m_tree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvulpes_1_1scipy_1_1ckdtree.html">scipy::ckdtree</a>&lt;Dim&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56a51f1e5fa97d0355226c30c177233b" name="a56a51f1e5fa97d0355226c30c177233b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a51f1e5fa97d0355226c30c177233b">&#9670;&#160;</a></span>m_tree_buffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int64_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structvulpes_1_1scipy_1_1ckdtreenode.html">scipy::ckdtreenode</a>&gt; <a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">vulpes::datastructure::KDTree</a>&lt; Dim &gt;::m_tree_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/vulpes/vulpes/vulpes/datastructure/<a class="el" href="kdtree_8hpp_source.html">kdtree.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevulpes.html">vulpes</a></li><li class="navelem"><a class="el" href="namespacevulpes_1_1datastructure.html">datastructure</a></li><li class="navelem"><a class="el" href="classvulpes_1_1datastructure_1_1KDTree.html">KDTree</a></li>
    <li class="footer">Generated on Fri Sep 26 2025 10:03:50 for Vulpes by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
