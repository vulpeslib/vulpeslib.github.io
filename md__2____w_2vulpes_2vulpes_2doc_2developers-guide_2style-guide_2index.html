<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulpes: C++ Style Guide</title>
<link rel="icon" href="vulpes_logo_notext_32.png" type="image/png" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-vulpes.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-vulpes.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vulpes
   &#160;<span id="projectnumber">0.0.1-alpha</span>
   </div>
   <div id="projectbrief">Virtual and Discontinuous Polytopal Elements Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2____w_2vulpes_2vulpes_2doc_2developers-guide_2style-guide_2index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C++ Style Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md37"></a> </p>
<h1><a class="anchor" id="autotoc_md38"></a>
Background</h1>
<p>This document attempts to define a unified style for C++ programming. It is heavily inspired by <a href="https://google.github.io/styleguide/cppguide.html">Google Coding style for C++ code</a>.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Formatting code</h1>
<ul>
<li>Format code automatically via clang-format and the provided <code>.clang-format</code> file.</li>
<li>Use Unix-style linebreaks (<code>\n</code>), not Windows-style (<code>\r\n</code>).</li>
<li>Each line of text in your code should be at most 80 characters long.</li>
<li>Non-ASCII characters should be rare, and must use UTF-8 formatting.</li>
<li>Use only spaces, and indent 2 spaces at a time.</li>
</ul>
<h1><a class="anchor" id="autotoc_md40"></a>
Static analysis</h1>
<ul>
<li>Use <code>cpplint.py</code> to detect style errors. It is not perfect, and has both false positives and false negatives.</li>
<li>Use <code>clang-tidy</code> to statically analyze the code: <div class="fragment"><div class="line">cmake &lt;options...&gt; -DCMAKE_EXPORT_COMPILE_COMMANDS=ON &lt;path&gt;</div>
<div class="line">run-clang-tidy -checks=&#39;google*,readability*,performance*,mpi*,cppcoreguidelines*,bugprone*,modernize-use-using,modernize-use-emplace,modernize-make-shared,modernize-make-unique&#39; -use-color</div>
</div><!-- fragment --></li>
<li>Use <a href="https://github.com/danmar/cppcheck">Cppcheck</a> to statically analyze the code: <div class="fragment"><div class="line">cmake &lt;options...&gt; -DCMAKE_EXPORT_COMPILE_COMMANDS=ON &lt;path&gt; </div>
<div class="line">cppcheck --project=compile_commands.json --check-level=exhaustive --inconclusive --enable=all</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md41"></a>
File structure</h1>
<p>In general, every header file (<code>.hpp</code>) should have an associated source file (<code>.cpp</code>). Header files should be self-contained (compile on their own).</p><ul>
<li>Filenames should be all lowercase and can include underscores (<code>_</code>)</li>
</ul>
<h2><a class="anchor" id="autotoc_md42"></a>
Define guard</h2>
<p>All header files should have <code>#define</code> guards to prevent multiple inclusion. The format of the symbol name should be <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code>. To guarantee uniqueness, they should be based on the full path in a project's source tree. For example, the file <code>foo/src/bar/baz.h</code> in project foo should have the following guard: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef FOO_BAR_BAZ_H_</span></div>
<div class="line"><span class="preprocessor">#define FOO_BAR_BAZ_H_</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">#endif  <span class="comment">// FOO_BAR_BAZ_H_</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md43"></a>
Includes</h2>
<p>Include headers in the following order: Related header, C system headers, C++ standard library headers, other libraries' headers, your project's headers. Separate each non-empty group with one blank line.</p>
<p><b>IMPORTANT:</b> If a source or header file refers to a symbol defined elsewhere, the file should directly include a header file which properly intends to provide a declaration or definition of that symbol. It should not include header files for any other reason. <b>Do not rely on transitive inclusions.</b></p>
<h1><a class="anchor" id="autotoc_md44"></a>
Namespaces</h1>
<p>With few exceptions, place code in a namespace. Namespaces should have unique names based on the project name, and possibly its path. Do not use using-directives (e.g., <code>using namespace foo</code>).</p><ul>
<li>You may not use a using-directive to make all names from a namespace available. <div class="fragment"><div class="line"><span class="comment">// FORBIDDEN -- This pollutes the namespace.</span></div>
<div class="line"><span class="keyword">using namespace </span>foo;</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md45"></a>
Variables</h1>
<h2><a class="anchor" id="autotoc_md46"></a>
Local Variables</h2>
<p>Place a function's variables in the narrowest scope possible.</p><ul>
<li>Initialize variables in the declaration. <div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line">i = f();      <span class="comment">// BAD -- initialization separate from declaration.</span></div>
<div class="line"><span class="keywordtype">int</span> i = f();  <span class="comment">// GOOD -- declaration has initialization.</span></div>
</div><!-- fragment --></li>
<li>Prefer initializing using brace initialization. <div class="fragment"><div class="line">std::vector&lt;int&gt; v; <span class="comment">// BAD -- Prefer initializing using brace initialization.</span></div>
<div class="line">v.push_back(1);  </div>
<div class="line">v.push_back(2);</div>
<div class="line">std::vector&lt;int&gt; v = {1, 2};  <span class="comment">// GOOD -- v starts initialized.</span></div>
</div><!-- fragment --></li>
<li>Variables needed for <code>if</code>, <code>while</code> and <code>for</code> statements should normally be declared within those statements <div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">const</span> <span class="keyword">auto</span> p = text.find(<span class="charliteral">&#39;/&#39;</span>, str)) {</div>
<div class="line">  str = p + 1;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>There is <b>one caveat</b>: if the variable is an object, its constructor is invoked every time it enters scope and is created, and its destructor is invoked every time it goes out of scope. <div class="fragment"><div class="line"><span class="comment">// INEFFICIENT implementation:</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">  std::vector&lt;double&gt; vector(10);  <span class="comment">// ctor and dtor get called 1000000 times each.</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 10; ++j) {</div>
<div class="line">    vector[j] = <span class="comment">//...</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// do stuff with vector</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BETTER implementation:</span></div>
<div class="line">std::vector&lt;double&gt; vector(10);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 10; ++j) {</div>
<div class="line">    vector[j] = <span class="comment">//...</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// do stuff with vector</span></div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ul>
<h2><a class="anchor" id="autotoc_md47"></a>
Global Variables</h2>
<p>Objects with static storage duration are forbidden unless they are trivially destructible. Note that fundamental types and variables marked with <code>constexpr</code> are trivially destructible. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> k_num = 10;  <span class="comment">// Allowed</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>X { <span class="keywordtype">int</span> n; };</div>
<div class="line"><span class="keyword">const</span> X k_x[] = {{1}, {2}, {3}};  <span class="comment">// Allowed</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> k_messages[] = {<span class="stringliteral">&quot;hello&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>};  <span class="comment">// Allowed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> std::array&lt;int, 3&gt; k_array = {1, 2, 3}; <span class="comment">// Allowed</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD: non-trivial destructor</span></div>
<div class="line"><span class="keyword">const</span> std::string k_foo = <span class="stringliteral">&quot;foo&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() {</div>
<div class="line">  <span class="comment">// BAD: non-trivial destructor.</span></div>
<div class="line">  <span class="keyword">static</span> std::map&lt;int, int&gt; k_data = {{1, 0}, {2, 0}, {3, 0}};</div>
<div class="line">}</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md48"></a>
Common patterns</h3>
<ul>
<li>Global strings: if you require a named global or static string constant, consider using a <code>constexpr</code> variable of <code>std::string_view</code> or character array <code>char k_str[]</code>.</li>
<li>Maps, sets, and other dynamic containers: if you require a static, fixed collection, such as a set to search against or a lookup table, you <b>cannot use</b> the dynamic containers from the standard library as a static variable, since they have non-trivial destructors. Instead, consider a simple array of trivial types, e.g., an array of arrays of ints (for a "map from int to int")</li>
</ul>
<h1><a class="anchor" id="autotoc_md49"></a>
Classes</h1>
<p>Classes are the fundamental unit of code in C++. Naturally, we use them extensively.</p><ul>
<li>Make classes' data members <code>private</code>, unless they are constants.</li>
<li>A class definition should usually start with a <code>public:</code> section, followed by <code>protected:</code>, then <code>private:</code>. Omit sections that would be empty.</li>
<li>Within each section, prefer grouping similar kinds of declarations together, and prefer the following order:<ul>
<li>Types and type aliases (typedef, using, enum, nested structs and classes, and friend types)</li>
<li>(Optionally, for structs only) non-static data members</li>
<li>Static constants</li>
<li>Factory functions</li>
<li>Constructors and assignment operators</li>
<li>Destructor</li>
<li>All other functions (static and non-static member functions, and friend functions)</li>
<li>All other data members (static and non-static)</li>
</ul>
</li>
<li>Do not define implicit conversions. Use the explicit keyword for conversion operators.</li>
</ul>
<h2><a class="anchor" id="autotoc_md50"></a>
Struct</h2>
<ul>
<li>Use a <code>struct</code> only for passive objects that carry data; everything else is a <code>class</code>.</li>
<li>Prefer to use a <code>struct</code> instead of a pair or a tuple whenever the elements can have meaningful names. <b>Caveat:</b> prefer a tuple if you heavily rely on comparing and swapping elements in a list (see <a href="https://stackoverflow.com/questions/5852261/c-tuple-vs-struct">C++ Tuple vs Struct</a>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md51"></a>
Inheritance</h2>
<ul>
<li>Composition is often more appropriate than inheritance. When using inheritance, make it public. Try to restrict use of inheritance to the "is-a" case.</li>
<li>Avoid virtual method calls in constructors.</li>
<li>Explicitly annotate overrides of virtual functions or virtual destructors with exactly one of an <code>override</code> or (less frequently) <code>final</code> specifier. Do not use <code>virtual</code> when declaring an override. Rationale: A function or destructor marked <code>override</code> or <code>final</code> that is not an override of a base class virtual function will not compile, and this helps catch common errors.</li>
<li>Polymorphism is powerful but expensive. Use polymorphism only if you are exploiting the run-time features it provides.</li>
</ul>
<h2><a class="anchor" id="autotoc_md52"></a>
Operator Overloading</h2>
<ul>
<li>Overload operators judiciously. Define overloaded operators only if their meaning is obvious, unsurprising, and consistent with the corresponding built-in operators.</li>
<li>Define operators only on your own types. More precisely, define them in the same headers, <code>.cpp</code> files, and namespaces as the types they operate on.</li>
<li>Prefer to define non-modifying binary operators as non-member functions. If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left-hand one. It will confuse your users if a + b compiles but b + a doesn't.</li>
<li>Do not overload <code>&amp;&amp;</code>, <code>||</code>, <code>,</code> (comma), or unary <code>&amp;</code>. Do not overload <code>operator""</code>, i.e., do not introduce user-defined literals.</li>
<li>Don't go out of your way to avoid defining operator overloads. For example, prefer to define <code>==</code>, <code>=</code>, and <code>&lt;&lt;</code>, rather than <code>Equals()</code>, <code>CopyFrom()</code>, and <code>PrintTo()</code>.</li>
<li>See <a href="https://en.cppreference.com/w/cpp/language/operators">cppreference</a> for more details</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Friends</h2>
<p>We allow use of friend classes and functions, within reason. Friends should usually be defined in the same file so that the reader does not have to look in another file to find uses of the private members of a class. A common use of <code>friend</code> is to have a <code>FooBuilder</code> class be a friend of Foo so that it can construct the inner state of Foo correctly, without exposing this state to the world. In some cases it may be useful to make a unittest class a friend of the class it tests.</p>
<h1><a class="anchor" id="autotoc_md54"></a>
Functions</h1>
<p>Even if C++ is Object-Oriented, do not be afraid of using free functions.</p><ul>
<li>Parameters are either <em>inputs</em> to the function, <em>outputs</em> from the function, or <em>both</em>. <br  />
<ul>
<li>Non-optional input parameters should usually be values or const references</li>
<li>Non-optional output and input/output parameters should usually be references</li>
</ul>
</li>
<li>When ordering function parameters, put all input-only parameters before any output parameters.</li>
<li>Avoid defining functions that require a <code>const</code> reference parameter to outlive the call, because <code>const</code> reference parameters bind to temporaries.</li>
<li>Prefer using return values over output parameters: they improve readability, and often provide the same or better performance (see <a href="https://en.cppreference.com/w/cpp/language/copy_elision">RVO</a>).</li>
<li>Prefer placing functions in a namespace. Use completely global functions rarely.</li>
<li><b>Do not</b> use a class simply to group static members. Static methods of a class should generally be closely related to instances of the class or the class's static data.</li>
<li>Define functions <code>inline</code> only when they are small, say, 10 lines or fewer.</li>
<li>Prefer small and focused functions. If a function exceeds about 40 lines, think about whether it can be broken up without harming the structure of the program.</li>
<li>Use trailing return types only where using the ordinary syntax (leading return types) is impractical or much less readable. <div class="fragment"><div class="line"><span class="keyword">auto</span> foo(<span class="keywordtype">int</span> x) -&gt; int; <span class="comment">// BAD: ordinary syntax is clear</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;     <span class="comment">// ALLOWED: ordinary syntax is much more verbose</span></div>
<div class="line"><span class="keyword">auto</span> add(T t, U u) -&gt; <span class="keyword">decltype</span>(t + u);</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md55"></a>
The &lt;tt&gt;auto&lt;/tt&gt; keyword</h1>
<p><code>auto</code> is a powerfull keyword as it allows to write generic code, especially when combined with templates. However, try to use it carefully, in particular bad thing can happen with template expression if the expression is not evaluated into a concrete type. E.g. </p><div class="fragment"><div class="line">Eigen::VectorXd someV(){</div>
<div class="line">  Eigen::VectorXd a(3);</div>
<div class="line">  a(1)=1.2;</div>
<div class="line">  a(2)=2.3;</div>
<div class="line">  a(0)=3.2;</div>
<div class="line">  <span class="keywordflow">return</span> a;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <span class="keyword">auto</span> c=2.*someV();</div>
<div class="line">  std::cout&lt;&lt;c;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> does not produce an output since <code>c</code> is an expression. For this reason try to <b>avoid using <code>auto</code></b> if you know the type of the result.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Exceptions</h1>
<p>We avoid C++ exceptions as much as possible. It pollutes the control flow.</p>
<h1><a class="anchor" id="autotoc_md57"></a>
Casting</h1>
<p>Use C++-style casts like <code>static_cast&lt;float&gt;(double_value)</code>, or brace initialization for conversion of arithmetic types like <code>int64_t y = int64_t{1} &lt;&lt; 42</code>. Do not use cast formats like <code>(int)x</code> unless the cast is to <code>void</code>. You may use cast formats like <code>T(x)</code> only when <code>T</code> is a class type.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
Integer Types</h1>
<p>It is often difficult to choose among the many built-in C++ integer types. Keep in mind that implicit casting from one type to another is <b>expensive</b>.</p><ul>
<li>When working with std containers use <code>size_t</code> for all the indexes</li>
<li>If a program needs an integer type of a different size, use an exact-width integer type from <code>&lt;cstdint&gt;</code>, such as <code>int16_t</code>.</li>
<li>Try as much as possible not to mix signedness</li>
</ul>
<h1><a class="anchor" id="autotoc_md59"></a>
Macros</h1>
<p><b>Avoid as much as possible defining macros</b>, especially in headers; prefer <code>inline</code> functions, <code>enums</code>, and <code>constexpr</code> variables.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Naming conventions</h1>
<h2><a class="anchor" id="autotoc_md61"></a>
Types</h2>
<ul>
<li>Classes, aliases of aggregate types and enums should use <code>PascalCase</code>.</li>
<li>Aliases of fundamental types should use <code>snake_case</code> with a trailing <code>_t</code>.</li>
<li>Functions and methods should use <code>camelCase</code></li>
<li>Everything else should use <code>snake_case</code>.</li>
</ul>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass {</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"><span class="keyword">enum class</span> Foo { Bar, Baz };</div>
<div class="line"><span class="keyword">using </span>VecD = std::vector&lt;double&gt;;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="namespacevulpes_1_1fe_1_1internal.html#a6603eb9554bb6b7399878a3bba383ad6">real_t</a> = float;</div>
<div class="ttc" id="anamespacevulpes_1_1fe_1_1internal_html_a6603eb9554bb6b7399878a3bba383ad6"><div class="ttname"><a href="namespacevulpes_1_1fe_1_1internal.html#a6603eb9554bb6b7399878a3bba383ad6">vulpes::fe::internal::real_t</a></div><div class="ttdeci">mpf_class real_t</div><div class="ttdef"><b>Definition</b> fe_space.hpp:190</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Variable prefixes</h2>
<ul>
<li>Private class attributes should have a prefix <code>m_</code></li>
<li>Static class attributes should have a prefix <code>s_</code></li>
<li><code>constexpr</code> and <code>const</code> integral variables should have a prefix <code>k_</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md63"></a>
Control structures</h1>
<p>Always brace controlled statements, even a single-line consequent of <code>if</code> or <code>for</code>. Examples: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (...) {</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (...) {</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">} <span class="keywordflow">while</span> (...);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (...; ...; ...) {</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md64"></a>
Switch</h2>
<ul>
<li>If an <code>if else</code> has more than one branch think to use a <code>switch</code></li>
<li>If not conditional on an enumerated value, <code>switch</code> statements should always have a default case</li>
</ul>
<h1><a class="anchor" id="autotoc_md65"></a>
Pointers</h1>
<ul>
<li>Prefer to have single, fixed owners for dynamically allocated objects. Prefer to transfer ownership with smart pointers. That is do not use the keyword <code>new</code>,</li>
<li>Use <code>nullptr</code> for pointers and <b>not</b> <code>NULL</code> or <code>0</code></li>
<li>When testing a pointer, use <code>(!my_ptr)</code> or <code>(my_ptr)</code>; don’t use <code>my_ptr != nullptr</code> or <code>my_ptr == nullptr</code>.</li>
<li>Do not compare <code>x == true</code> or <code>x == false</code>. Use <code>(x)</code> or <code>(!x)</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md66"></a>
Return from errors immediately</h1>
<p>In most cases, your knee-jerk reaction should be to return from the current function. Don’t do this: </p><div class="fragment"><div class="line">rv = foo-&gt;call1();</div>
<div class="line"><span class="keywordflow">if</span> (rv) {</div>
<div class="line">  rv = foo-&gt;call2();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> rv;</div>
</div><!-- fragment --><p> Instead, do this: </p><div class="fragment"><div class="line">rv = foo-&gt;call1();</div>
<div class="line"><span class="keywordflow">if</span> (!rv) {</div>
<div class="line">  <span class="keywordflow">return</span> rv;</div>
<div class="line">}</div>
<div class="line">rv = foo-&gt;call2();</div>
<div class="line"><span class="keywordflow">return</span> rv;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Sep 24 2025 17:13:47 for Vulpes by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
